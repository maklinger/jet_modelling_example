# KARIBA


The Kariba library (named after Lake Kariba in Zimbabwe) is a group of c++ classes designed to solve common problems in high energy astrophysics. It currently includes several classes inherited from two general classes - particle.hpp and radiation.hpp. The first one deals with particle distributions, the second with radiative mechanisms as well as spectral components commonly found in astrophysical sources. Currently the only radiating particles supported are leptons; hadrons will be included in the near/intermediate future. Every other class in the library is inherited from these either one of these two classes. 
 
---------------------------------------------------------------------------------------------------------------------------------------

Particle distributions:
These classes are designed to treat both non-relativistic and relativistic particle distributions. This requires the particle distributions to be written in units of momentum, and the number density to be particles per unit volume, per unit momentum. The class also automatically initializes and calculates the distribution in Lorentz factor space - the Lorentz factor is calculated from the particle momentum, and the corresponding number density is written in units of particles per unit volume, per unit Lorentz factor. One important point in using all of these classes is that, before calculating the number densities with the .set\_ndens() member, users need to set every other relevant quantity (temperature, non-thermal slopes, etc) needs to be set explicitely by the user. Then, the normalisation is set by calling the .set\_norm(n) member function. This method requires knowing n, the total number density per unit volume of particles, in advance. _The set\_ndens() method can only be called after this is done_. The functions used to integrate the particle distributions are friend members; this allows the functions to access the protected and private members of the class, and to also have the correct input parameters (a double and a void pointer) for integrating with the GSL libraries. For all derived classes, the constructor only requires passing the size of the arrays to be used. The classes that share this structure are:

- Particles : This is the prototype class for all distributions; it containes basic methods to manipulate and test arrays that are common and shared between all distributions, as well as a generalised class destructor.

- Thermal : This distribution follows a Maxwell-Juttner distribution in momentum space, and can treat both relativistic temperatures (> 511 keV) and non-relativistic temperatures down to ~1 keV. Below this threshold, the normalization of the M-J distribution diverges due to numerical errors, and the number density array returns only nan. This class does not contain methods to solve the continuity equation, as it makes no sense to do so if one assumes the distribution is thermalized in the first place.

- Powerlaw : This distribution follows a N0*p^(-s)*exp(-p/pmax) exponentially cutoff power-law distribution in momentum space; for large values of p, it reduces to a standard power-law distribution in Lorentz factor space as well.

- Bknpower : This distribution follows a smoothly broken power-law distribution in momentum space; for large values of p, it reduces to a standard broken power-law distribution in Lorentz factor (e.g. Ghisellini et al. 2009) space as well. 

- Kappa : This distribution follows a k-distribution in Lorentz factor space (e.g. Develaar et al. 2017), which is then converted in the appropriate distribution in momentum space; the k- distribution roughly mimics a Maxwell-Juttner distribution with a power-law tail of slope k+1, where k is the index that defines the Kappa distribution. 

- Mixed : This distribution follows a hybrid thermal/non-thermal distribution, as traditionally done in the agnjet model (e.g. Markoff et al. 2001, 2005). The ratio of non-thermal to thermal particles is set by the .set\_plfrac(f) method; a fraction f is assumed to be non-thermal and follows the same distribution and methods as the Powerlaw class, while the remaining fraction 1-f is thermal (and is therefore treated identically to the Thermal.hpp class). 

The classes powerlaw, bknpower, kappa and mixed all have methods to both set the maximum momentum of the particles, and solve the steady-state continuity equation, for a given set of physical conditions in the source. The .set\_p() method allows one to set the maximum momentum of the distribution by comparing the acceleration and cooling time-scales (including adiabatic cooling, synchrotron cooling, and inverse Compton cooling, and neglectic Klein-Nishina effects). Alternatively, it is possible to simply specify a desired maximum Lorentz factor in each distribution. The .cooling\_steadystate() method allows one to solve the continuity equation assuming continuous injection of particles, and knowing the adiabatic and radiative timescales loss terms in the source (neglecting Klein-Nishina effects as the .set\_p() method). 

---------------------------------------------------------------------------------------------------------------------------------------

Radiative mechanisms:
These classes are designed to calculate the emission of spectral components commonly found in the SEDs of high energy sources. These can either be related to particle distributions described above (e.g. cyclosynchrotron, inverse Compton), but that need not be the case (e.g. black body, accretion disk). Each class always uses two different sets of arrays; one in the comoving frame of the source (en\_phot, num\_phot), and one in the observer frame (en\_phot\_obs, num\_phot\_obs), automatically accounting for viewing angle and Doppler boosting effects, but not for cosmological redshift. The energy of the photons is always expressed in erg, and the luminosity for each energy bin is expressed in erg/s/Hz. _Like the case of the particle distributions, the constructors for each object only require the desired size of the arrays, and every physical quantity (magnetic field, frequency intervals, Thomson optical depths, etc) needs to be set explicitely with the setter functions by the user before calculating the spectra_. 

- Radiation : This is the prototype class for all the spectral components treated; it containes basic methods to manipulate and test arrays that are common and shared between all classes. Note that before calculating the spectra one needs to set the geometry of the source (assumed to be homogeneous); the only exception to this is the ShSDisk class, which assumes a Shakura-Sunyaev type disk and therefore sets the geometry internally. It is also possible to include the presence of both an approaching and receding source (effectively, a counterjet) with different Lorentz factors; the class does so by extending the size of the \_obs arrays. 

- BBody : This class calculates the emission from a thermalized, optically thick source emitting black body radiation of given temperature (in Kelvin or keV) and luminosity (in erg/s). It is also possible to return the energy density seen by an observer standing at rest, at a distance d from the source.

- ShSDisk : This class treats a truncated, optically thick, geometrically thin, Shakura-Sunyaev type disk. The disk is assumed to be truncated at a distance Rin (expressed in Rg); at this distance, it is possible to either define the temperature and calculated the corresponding luminosity, or vice versa, through the constructor. The scale height H/R of the disk is assumed to be max(0.1,L), where L is the luminosity in Eddington units, H the disk height, and R the disk radius. H/R is therefore constant throughout the disk, and the farther away one moves from the central engine, the thicker the disk gets in units of Rg. This behavior physically roughly mimics the Shakura-Sunyaev model (Shakura and Sunyaev 1973): for low (<10% Eddington) accretion rates H/R is driven by the viscosity alpha parameter (whose value is typically 0.1), but for higher accretion rates radiation pressure can start puffing up the disk. Note that this is NOT a self-consistent treatement of a slim disk model. 

- Cyclosyn : This class calculates the cyclosynchrotron emission from a population of particles in both the relativistic and non-relativistic regime.  The emissivity for the non-relativistic regime is the phenomenlogical treatement of Petrosian (1981), while in the relativistic regime the treatement is that of Bloumethal and Gould (1970). Before running the calculations, one needs to specify the magnetic field with the .set\_bfield() method. The absorption coefficient is calculated by integrating by parts - therefore, one needs to know the differential of the particle distribution. In order to calculate the spectrum one needs to call the .cycsyn\_spectrum() method, which requires knowledge of the minimum and maximum Lorentz factor of the particle distribution, as well as both the electron distribution and its differential in Lorentz factor units. The latter two need to be gsl\_spline objects.

- Compton : This class calculates the inverse Compton emission from a population of particles in both the relativistic and non-relativistic regime. In both cases, the calculations are found in Bloumethal and Gould (1970). The code accounts both for Klein-Nishina effects as well as multiple scatters, and is optimized for optical depths of up to ~a few in order to probe X-ray coronae of accreting black holes. There are two important notes on using this class in the multiple scatter regime. Frist, this class is the most computationally expensive of the library, especially in the case of multiple scatters. Second, the code automatically recognizes when the photon to be scattered has more energy than the electron doing the scattering. Therefore specifying the exact number of scatters physically happening is not necessary; typically, using more than ~15 scatters slows down the code without any change to the spectrum. Different seed fields can be used. It is possible to calculate SSC emission, using the en\_phot and num\_phot arrays from the Cyclosyn class, or to scatter black body photons (described by an energy density in erg/cm and a temperature in keV), or to scatter disk photons in a lamp-post geometry (described by a disk temperature in Kelvin, an inner and outer radius in Rg, a scale height h, at a distance z -in Rg- from the disk). 

---------------------------------------------------------------------------------------------------------------------------------------
